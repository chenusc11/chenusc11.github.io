<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¯çˆ±å›¾æ ‡è¿è¿çœ‹</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            background-color: #f0f8ff;
            margin: 10px 0;
            color: #333;
            user-select: none;
            overflow-x: hidden;
        }

        .container {
            text-align: center;
            background-color: #fff5f5;
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);
            max-width: 98vw;
        }

        h1 {
            color: #ff6384;
            margin-bottom: 10px;
            font-size: 1.8em;
        }

        .info-panel {
            display: flex;
            flex-direction: column; /* Stack elements vertically */
            align-items: center; /* Center items horizontally */
            margin-bottom: 10px;
            font-size: 1em;
        }

        .control-buttons { /* New container for buttons */
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            align-items: center; /* Align items including dropdown */
            margin-bottom: 10px; /* Space between buttons and stats */
        }

        .stats-display { /* New container for timer and score */
            display: flex;
            justify-content: space-around; /* Space out timer and score */
            align-items: center;
            width: 100%; /* Make it take full width to space items */
            max-width: 300px; /* Optional: constrain width of stats */
        }


        #timer, #score {
            background-color: #ffecf0;
            padding: 8px 15px;
            border-radius: 8px;
            color: #c75b75;
            font-weight: bold;
            min-width: 100px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.05);
            margin: 5px;
        }

        #restart-button, #mode-toggle-button, #size-toggle-button, #share-button, #test-win-button { /* Added #test-win-button */
            background-color: #ff8fab;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin: 5px;
        }

        #restart-button:hover, #mode-toggle-button:hover, #size-toggle-button:hover, #share-button:hover, #test-win-button:hover { /* Added #test-win-button */
            background-color: #ff6384;
        }
        #restart-button:active, #mode-toggle-button:active, #size-toggle-button:active, #share-button:active, #test-win-button:active { /* Added #test-win-button */
            transform: scale(0.98);
        }

        /* Style for the language selector */
        #language-selector {
            background-color: #ff8fab;
            color: white;
            border: none;
            padding: 8px 10px; /* Slightly smaller padding than buttons */
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85em; /* Slightly smaller font */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin: 5px;
            -webkit-appearance: none; /* Remove default styling */
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23ffffff%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.4-5.4-13z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: .65em auto;
            padding-right: 30px; /* Make space for arrow */
        }
         #language-selector:hover {
            background-color: #ff6384;
        }


        #game-board {
            display: grid;
            gap: 2px;
            background-color: #ffffff;
            padding: 5px;
            border: 2px solid #ffc0cb;
            border-radius: 10px;
            /* Width will be set by JavaScript */
            margin: 10px auto;
        }

        .tile {
            width: 32px;
            height: 32px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #fff0f5;
            border: 1px solid #f8bbd0;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.15s ease, transform 0.15s ease;
            overflow: hidden;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            font-size: 20px;
            box-sizing: border-box;
        }

        .tile img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            display: block;
        }

        .tile:hover {
            background-color: #fce4ec;
            transform: scale(1.05);
        }

        .tile.selected {
            background-color: #ffd700;
            transform: scale(1.1);
            box-shadow: 0 0 8px #ffd700;
            border-color: #ffc107;
        }

        .tile.hidden {
            visibility: hidden !important;
            cursor: default;
            background-color: transparent !important;
            box-shadow: none !important;
            border-color: transparent !important;
        }
        .tile.hidden img { display: none !important; }
        .tile.hidden * { visibility: hidden !important; }


        #message-box {
            margin-top: 15px;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: bold;
            min-height: 40px; /* Ensure space for messages */
            box-sizing: border-box;
        }

        #message-box.success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        #message-box.error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .hidden-message-box { display: none !important; }

        .loader {
            border: 4px solid #f3f3f3;
            border-radius: 50%;
            border-top: 4px solid #ff6384;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 data-translate-key="gameTitle">å¯çˆ±å›¾æ ‡è¿è¿çœ‹</h1>
        <div class="info-panel">
            <div class="control-buttons">
                
                <button id="mode-toggle-button" data-translate-key="modeButtonHell">åˆ‡æ¢åˆ°åœ°ç‹±æ¨¡å¼</button>
                <button id="size-toggle-button" data-translate-key="sizeButtonHard">åˆ‡æ¢åˆ°16x16</button>
                <button id="restart-button" data-translate-key="restartButton">é‡æ–°å¼€å§‹</button>
                <!-- <button id="test-win-button" data-translate-key="testWinButton">æµ‹è¯•èƒœåˆ©</button> // for testing do not delete -->
            </div>
            <div class="stats-display">
                <select id="language-selector">
                    <option value="zh">zh-CN</option>
                    <option value="en">EN</option>
                    <option value="ko">í•œêµ­ì–´</option>
                    <option value="ja">æ—¥æœ¬èª</option>
                </select>
                <div id="timer"><span data-translate-key="timerLabel">æ—¶é—´</span>: <span>600</span>s</div>
                <div id="score"><span data-translate-key="scoreLabel">å¾—åˆ†</span>: <span>0</span></div>
            </div>
        </div>
        <div id="game-board">
            <div class="loader" id="loading-indicator"></div>
        </div>
        <div id="message-box" class="hidden-message-box"></div>
        <button id="share-button" style="display:none; margin-top: 10px;" data-translate-key="shareButton">åˆ†äº«æˆç»©</button> 
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Element References
            const gameBoardElement = document.getElementById('game-board');
            const timerValueElement = document.getElementById('timer').querySelector('span:last-child'); // Get the number span
            const scoreValueElement = document.getElementById('score').querySelector('span:last-child'); // Get the number span
            const timerLabelElement = document.getElementById('timer').querySelector('span:first-child');
            const scoreLabelElement = document.getElementById('score').querySelector('span:first-child');

            const restartButton = document.getElementById('restart-button');
            const messageBox = document.getElementById('message-box');
            const loadingIndicator = document.getElementById('loading-indicator');
            const modeToggleButton = document.getElementById('mode-toggle-button');
            const sizeToggleButton = document.getElementById('size-toggle-button');
            const shareButton = document.getElementById('share-button'); 
            const testWinButton = document.getElementById('test-win-button');
            const languageSelector = document.getElementById('language-selector'); // Language selector
            const gameTitleElement = document.querySelector('h1');


            // --- Start of Internationalization (i18n) Setup ---
            let currentLanguage = 'zh'; // Default language

            const translations = {
                zh: {
                    gameTitle: "å¯çˆ±å›¾æ ‡è¿è¿çœ‹",
                    modeButtonHell: "åˆ‡æ¢åˆ°åœ°ç‹±æ¨¡å¼",
                    modeButtonCasual: "åˆ‡æ¢åˆ°ä¼‘é—²æ¨¡å¼",
                    sizeButtonHard: `åˆ‡æ¢åˆ°16x16`,
                    sizeButtonEasy: `åˆ‡æ¢åˆ°10x8`,
                    restartButton: "é‡æ–°å¼€å§‹",
                    // testWinButton: "æµ‹è¯•èƒœåˆ©", // Uncomment if using
                    timerLabel: "æ—¶é—´",
                    scoreLabel: "å¾—åˆ†",
                    shareButton: "åˆ†äº«æˆç»©",
                    winMessage: "å¤ªæ£’äº†ï¼æ‰€æœ‰å›¾æ ‡éƒ½æ‰¾åˆ°ä¼™ä¼´å•¦ï¼ğŸ‰",
                    loseMessage: "æ—¶é—´åˆ°ï¼ä¸‹æ¬¡åŠªåŠ›å“¦ï¼ğŸ˜¢",
                    testWinPrompt: "è¯·å…ˆåˆ‡æ¢åˆ°åœ°ç‹±æ¨¡å¼å†æµ‹è¯•èƒœåˆ©ã€‚",
                    noUniqueImagesPreload: "æ²¡æœ‰å”¯ä¸€çš„å›¾ç‰‡éœ€è¦é¢„åŠ è½½ã€‚",
                    noImagesOrPathError: "æ²¡æœ‰å›¾ç‰‡éœ€è¦é¢„åŠ è½½æˆ– CUTE_ICONS_SOURCES ä¸ºç©ºã€‚è¯·æ£€æŸ¥ NUM_UNIQUE_ICONS å’Œå›¾ç‰‡è·¯å¾„ã€‚",
                    preloadError: (src, path) => `é¢„åŠ è½½å›¾ç‰‡é”™è¯¯: ${src}ã€‚ç¡®ä¿å›¾ç‰‡å­˜åœ¨äº '${path}' ç›®å½•ä¸‹ã€‚`,
                    oddTilesError: "æ£‹ç›˜æ ¼å­æ€»æ•°å¿…é¡»æ˜¯å¶æ•°æ‰èƒ½é…å¯¹ï¼è¯·æ£€æŸ¥è¡Œåˆ—è®¾ç½®ã€‚",
                    noIconSourcesError: "é”™è¯¯ï¼šæ²¡æœ‰å¯ç”¨çš„å›¾æ ‡æ¥æº (CUTE_ICONS_SOURCES ä¸ºç©º)ã€‚æ¸¸æˆå°†ä½¿ç”¨å ä½ç¬¦ã€‚",
                    notEnoughUniqueIconsWarning: (unique, needed) => `è­¦å‘Š: å”¯ä¸€å›¾æ ‡æ•°é‡ (${unique}) å¯èƒ½ä¸è¶³ä»¥å¡«æ»¡ ${needed} å¯¹æ ¼å­ã€‚å›¾æ ‡å°†ä¼šé‡å¤ã€‚`,
                    notEnoughPairsError: (r, c) => `åœ¨ [${r},${c}] å¤„æ²¡æœ‰è¶³å¤Ÿçš„å›¾æ ‡é…å¯¹ã€‚`,
                    renderImageLoadError: (src) => `æ¸²æŸ“æ—¶å›¾ç‰‡åŠ è½½å¤±è´¥: ${src}. æ˜¾ç¤ºå ä½ç¬¦ã€‚`,
                    invalidTileClick: (r,c) => `ç‚¹å‡»äº†æ— æ•ˆæˆ–å·²æ¸…é™¤çš„æ ¼å­: [${r},${c}]`,
                    shareScoreText: (score, url) => `æˆ‘åœ¨ã€Šå¯çˆ±å›¾æ ‡è¿è¿çœ‹ã€‹åœ°ç‹±æ¨¡å¼ä¸­è·å¾—äº† ${score} åˆ†ï¼ä½ ä¹Ÿæ¥è¯•è¯•å§ï¼ ${url}`,
                    shareTitle: "ç‚«è€€æˆ‘çš„è¿è¿çœ‹æˆç»©ï¼",
                    shareSuccessLog: "æˆåŠŸåˆ†äº«ï¼",
                    shareCancelledLog: "åˆ†äº«æ“ä½œå¯èƒ½è¢«å–æ¶ˆæˆ–å¤±è´¥:",
                    copySuccessMessage: "åˆ†äº«å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼Œå¿«å»ç²˜è´´åˆ†äº«å§ï¼",
                    copyErrorMessage: "å¤åˆ¶åˆ†äº«å†…å®¹å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ã€‚",
                    copyCommandUnsuccessful: "Fallback: Copying text command was unsuccessful",
                    copyUnableError: "Fallback: Oops, unable to copy",
                    unsupportedShareMessage: "ä½ çš„æµè§ˆå™¨ä¸æ”¯æŒç›´æ¥åˆ†äº«ï¼Œåˆ†äº«å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼"
                },
                en: {
                    gameTitle: "Cute Icon Match-Up",
                    modeButtonHell: "Switch to Hell Mode",
                    modeButtonCasual: "Switch to Casual Mode",
                    sizeButtonHard: "Switch to 16x16",
                    sizeButtonEasy: "Switch to 10x8",
                    restartButton: "Restart",
                    // testWinButton: "Test Win", // Uncomment if using
                    timerLabel: "Time",
                    scoreLabel: "Score",
                    shareButton: "Share Score",
                    winMessage: "Awesome! All icons found their partners! ğŸ‰",
                    loseMessage: "Time's up! Better luck next time! ğŸ˜¢",
                    testWinPrompt: "Please switch to Hell Mode before testing win.",
                    noUniqueImagesPreload: "No unique images to preload.",
                    noImagesOrPathError: "No images to preload or CUTE_ICONS_SOURCES is empty. Check NUM_UNIQUE_ICONS and image path.",
                    preloadError: (src, path) => `Error preloading image: ${src}. Ensure it exists in '${path}'.`,
                    oddTilesError: "Total number of board tiles must be even for pairing! Check row/column settings.",
                    noIconSourcesError: "Error: No icon sources available (CUTE_ICONS_SOURCES is empty). Game will use placeholders.",
                    notEnoughUniqueIconsWarning: (unique, needed) => `Warning: Number of unique icons (${unique}) may not be enough for ${needed} pairs. Icons will repeat.`,
                    notEnoughPairsError: (r, c) => `Not enough icon pairs at [${r},${c}].`,
                    renderImageLoadError: (src) => `Image failed to load during render: ${src}. Showing placeholder.`,
                    invalidTileClick: (r,c) => `Clicked invalid or cleared tile: [${r},${c}]`,
                    shareScoreText: (score, url) => `I scored ${score} in "Cute Icon Match-Up" (Hell Mode)! Come and try it! ${url}`,
                    shareTitle: "Show off my Match-Up score!",
                    shareSuccessLog: "Shared successfully!",
                    shareCancelledLog: "Share operation may have been cancelled or failed:",
                    copySuccessMessage: "Share content copied to clipboard! Go paste and share!",
                    copyErrorMessage: "Failed to copy share content, please copy manually.",
                    copyCommandUnsuccessful: "Fallback: Copying text command was unsuccessful",
                    copyUnableError: "Fallback: Oops, unable to copy",
                    unsupportedShareMessage: "Your browser doesn't support direct sharing. Share content copied to clipboard!"
                },
                ko: { // éŸ©è¯­ç¿»è¯‘
                    gameTitle: "ê·€ì—¬ìš´ ì•„ì´ì½˜ ì§ ë§ì¶”ê¸°",
                    modeButtonHell: "í—¬ ëª¨ë“œ",
                    modeButtonCasual: "ìºì£¼ì–¼ ëª¨ë“œ",
                    sizeButtonHard: "16x16ëª¨ë“œ",
                    sizeButtonEasy: "10x8ëª¨ë“œ",
                    restartButton: "ë‹¤ì‹œ ì‹œì‘",
                    timerLabel: "ì‹œê°„",
                    scoreLabel: "ì ìˆ˜",
                    shareButton: "ì ìˆ˜ ê³µìœ ",
                    winMessage: "ì¶•í•˜í•©ë‹ˆë‹¤! ëª¨ë“  ì•„ì´ì½˜ì˜ ì§ì„ ì°¾ì•˜ìŠµë‹ˆë‹¤! ğŸ‰",
                    loseMessage: "ì‹œê°„ ì´ˆê³¼! ë‹¤ìŒì— ë‹¤ì‹œ ë„ì „í•˜ì„¸ìš”! ğŸ˜¢",
                    testWinPrompt: "ìŠ¹ë¦¬ í…ŒìŠ¤íŠ¸ ì „ì— í—¬ ëª¨ë“œë¡œ ì „í™˜í•´ì£¼ì„¸ìš”.",
                    noUniqueImagesPreload: "ë¯¸ë¦¬ ë¡œë“œí•  ê³ ìœ  ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.",
                    noImagesOrPathError: "ë¯¸ë¦¬ ë¡œë“œí•  ì´ë¯¸ì§€ê°€ ì—†ê±°ë‚˜ CUTE_ICONS_SOURCESê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤. NUM_UNIQUE_ICONS ë° ì´ë¯¸ì§€ ê²½ë¡œë¥¼ í™•ì¸í•˜ì„¸ìš”.",
                    preloadError: (src, path) => `ì´ë¯¸ì§€ ë¯¸ë¦¬ ë¡œë“œ ì˜¤ë¥˜: ${src}. '${path}'ì— ì´ë¯¸ì§€ê°€ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.`,
                    oddTilesError: "ì§ì„ ë§ì¶”ë ¤ë©´ ë³´ë“œ íƒ€ì¼ì˜ ì´ ê°œìˆ˜ê°€ ì§ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤! í–‰/ì—´ ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.",
                    noIconSourcesError: "ì˜¤ë¥˜: ì‚¬ìš© ê°€ëŠ¥í•œ ì•„ì´ì½˜ ì†ŒìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤ (CUTE_ICONS_SOURCESê°€ ë¹„ì–´ ìˆìŒ). ê²Œì„ì—ì„œ ìë¦¬ í‘œì‹œìë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.",
                    notEnoughUniqueIconsWarning: (unique, needed) => `ê²½ê³ : ê³ ìœ  ì•„ì´ì½˜ ìˆ˜(${unique})ê°€ ${needed}ìŒì„ ì±„ìš°ê¸°ì— ì¶©ë¶„í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì•„ì´ì½˜ì´ ë°˜ë³µë©ë‹ˆë‹¤.`,
                    notEnoughPairsError: (r, c) => `[${r},${c}]ì— ì•„ì´ì½˜ ìŒì´ ì¶©ë¶„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`,
                    renderImageLoadError: (src) => `ë Œë”ë§ ì¤‘ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨: ${src}. ìë¦¬ í‘œì‹œìë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.`,
                    invalidTileClick: (r,c) => `ì˜ëª»ë˜ì—ˆê±°ë‚˜ ì´ë¯¸ ì œê±°ëœ íƒ€ì¼ì„ í´ë¦­í–ˆìŠµë‹ˆë‹¤: [${r},${c}]`,
                    shareScoreText: (score, url) => `"ê·€ì—¬ìš´ ì•„ì´ì½˜ ì§ ë§ì¶”ê¸°" (í—¬ ëª¨ë“œ)ì—ì„œ ${score}ì ì„ íšë“í–ˆìŠµë‹ˆë‹¤! ë‹¹ì‹ ë„ ë„ì „í•´ë³´ì„¸ìš”! ${url}`,
                    shareTitle: "ì ìˆ˜ ê³µìœ í•˜ê¸°!",
                    shareSuccessLog: "ì„±ê³µì ìœ¼ë¡œ ê³µìœ ë˜ì—ˆìŠµë‹ˆë‹¤!",
                    shareCancelledLog: "ê³µìœ  ì‘ì—…ì´ ì·¨ì†Œë˜ì—ˆê±°ë‚˜ ì‹¤íŒ¨í–ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤:",
                    copySuccessMessage: "ê³µìœ  ë‚´ìš©ì´ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤! ë¶™ì—¬ë„£ê³  ê³µìœ í•˜ì„¸ìš”!",
                    copyErrorMessage: "ê³µìœ  ë‚´ìš© ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ë³µì‚¬í•´ì£¼ì„¸ìš”.",
                    copyCommandUnsuccessful: "í´ë°±: í…ìŠ¤íŠ¸ ë³µì‚¬ ëª…ë ¹ì´ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
                    copyUnableError: "í´ë°±: ì£„ì†¡í•©ë‹ˆë‹¤, ë³µì‚¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
                    unsupportedShareMessage: "ë¸Œë¼ìš°ì €ì—ì„œ ì§ì ‘ ê³µìœ ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ê³µìœ  ë‚´ìš©ì´ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!"
                },
                ja: { // æ—¥è¯­ç¿»è¯‘
                    gameTitle: "ã¤ãªã’ã¦ãƒãƒ³!",
                    modeButtonHell: "ãƒ˜ãƒ«ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ",
                    modeButtonCasual: "ã‚«ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ",
                    sizeButtonHard: "16x16ã«åˆ‡ã‚Šæ›¿ãˆ",
                    sizeButtonEasy: "10x8ã«åˆ‡ã‚Šæ›¿ãˆ",
                    restartButton: "å†é–‹ã™ã‚‹",
                    timerLabel: "æ™‚é–“",
                    scoreLabel: "ã‚¹ã‚³ã‚¢",
                    shareButton: "ã‚¹ã‚³ã‚¢ã‚’å…±æœ‰",
                    winMessage: "ç´ æ™´ã‚‰ã—ã„ï¼ã™ã¹ã¦ã®ã‚¢ã‚¤ã‚³ãƒ³ãŒãƒšã‚¢ã‚’è¦‹ã¤ã‘ã¾ã—ãŸï¼ğŸ‰",
                    loseMessage: "æ™‚é–“åˆ‡ã‚Œã§ã™ï¼ã¾ãŸæŒ‘æˆ¦ã—ã¦ãã ã•ã„ï¼ğŸ˜¢",
                    testWinPrompt: "å‹åˆ©ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹å‰ã«ãƒ˜ãƒ«ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆã¦ãã ã•ã„ã€‚",
                    noUniqueImagesPreload: "äº‹å‰ã«èª­ã¿è¾¼ã‚€ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªç”»åƒã¯ã‚ã‚Šã¾ã›ã‚“ã€‚",
                    noImagesOrPathError: "äº‹å‰ã«èª­ã¿è¾¼ã‚€ç”»åƒãŒãªã„ã‹ã€CUTE_ICONS_SOURCESãŒç©ºã§ã™ã€‚NUM_UNIQUE_ICONSã¨ç”»åƒãƒ‘ã‚¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚",
                    preloadError: (src, path) => `ç”»åƒã®äº‹å‰èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${src}ã€‚ '${path}'ã«ç”»åƒãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`,
                    oddTilesError: "ãƒšã‚¢ãƒªãƒ³ã‚°ã™ã‚‹ã«ã¯ã€ãƒœãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ«ã®ç·æ•°ãŒå¶æ•°ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼è¡Œ/åˆ—ã®è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚",
                    noIconSourcesError: "ã‚¨ãƒ©ãƒ¼ï¼šåˆ©ç”¨å¯èƒ½ãªã‚¢ã‚¤ã‚³ãƒ³ã‚½ãƒ¼ã‚¹ãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆCUTE_ICONS_SOURCESã¯ç©ºã§ã™ï¼‰ã€‚ã‚²ãƒ¼ãƒ ã¯ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚",
                    notEnoughUniqueIconsWarning: (unique, needed) => `è­¦å‘Šï¼šãƒ¦ãƒ‹ãƒ¼ã‚¯ãªã‚¢ã‚¤ã‚³ãƒ³ã®æ•°ï¼ˆ${unique}ï¼‰ãŒã€${needed}ãƒšã‚¢ã‚’åŸ‹ã‚ã‚‹ã®ã«ååˆ†ã§ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ã‚¢ã‚¤ã‚³ãƒ³ã¯ç¹°ã‚Šè¿”ã•ã‚Œã¾ã™ã€‚`,
                    notEnoughPairsError: (r, c) => `[${r},${c}]ã«ååˆ†ãªã‚¢ã‚¤ã‚³ãƒ³ãƒšã‚¢ãŒã‚ã‚Šã¾ã›ã‚“ã€‚`,
                    renderImageLoadError: (src) => `ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ä¸­ã«ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${src}ã€‚ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚`,
                    invalidTileClick: (r,c) => `ç„¡åŠ¹ã¾ãŸã¯ã‚¯ãƒªã‚¢ã•ã‚ŒãŸã‚¿ã‚¤ãƒ«ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã—ãŸ: [${r},${c}]`,
                    shareScoreText: (score, url) => `ã€Œã¤ãªã’ã¦ãƒãƒ³ï¼ã€ï¼ˆãƒ˜ãƒ«ãƒ¢ãƒ¼ãƒ‰ï¼‰ã§${score}ç‚¹ã‚’ç²å¾—ã—ã¾ã—ãŸï¼ã‚ãªãŸã‚‚è©¦ã—ã¦ã¿ã¾ã›ã‚“ã‹ï¼Ÿ ${url}`,
                    shareTitle: "ã‚¹ã‚³ã‚¢ã‚’ã¿ã‚“ãªã«è¦‹ã›ã‚ˆã†ï¼",
                    shareSuccessLog: "æ­£å¸¸ã«å…±æœ‰ã•ã‚Œã¾ã—ãŸï¼",
                    shareCancelledLog: "å…±æœ‰æ“ä½œãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸã‹ã€å¤±æ•—ã—ãŸå¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ï¼š",
                    copySuccessMessage: "å…±æœ‰ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã—ãŸï¼è²¼ã‚Šä»˜ã‘ã¦å…±æœ‰ã—ã¦ãã ã•ã„ï¼",
                    copyErrorMessage: "å…±æœ‰ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ‰‹å‹•ã§ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„ã€‚",
                    copyCommandUnsuccessful: "ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šãƒ†ã‚­ã‚¹ãƒˆã‚³ãƒ”ãƒ¼ã‚³ãƒãƒ³ãƒ‰ãŒå¤±æ•—ã—ã¾ã—ãŸ",
                    copyUnableError: "ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€ã‚³ãƒ”ãƒ¼ã§ãã¾ã›ã‚“ã§ã—ãŸ",
                    unsupportedShareMessage: "ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ç›´æ¥å…±æœ‰ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚å…±æœ‰ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã—ãŸï¼"
                }
            };

            function _t(key, ...args) { // Simple translation function
                const langSet = translations[currentLanguage];
                if (langSet && langSet[key]) {
                    if (typeof langSet[key] === 'function') {
                        return langSet[key](...args);
                    }
                    return langSet[key];
                }
                // Fallback to English if key not found in current language, then to key itself
                const fallbackLangSet = translations['en'];
                if (fallbackLangSet && fallbackLangSet[key]) {
                     if (typeof fallbackLangSet[key] === 'function') {
                        return fallbackLangSet[key](...args);
                    }
                    return fallbackLangSet[key];
                }
                console.warn(`Translation missing for key: ${key}, lang: ${currentLanguage}`);
                return key; // Return key if no translation found
            }

            function applyTranslations() {
                document.title = _t("gameTitle");
                gameTitleElement.textContent = _t("gameTitle");
                
                timerLabelElement.textContent = _t("timerLabel");
                scoreLabelElement.textContent = _t("scoreLabel");
                restartButton.textContent = _t("restartButton");
                // if (testWinButton) testWinButton.textContent = _t("testWinButton"); // Uncomment if using
                if (shareButton) shareButton.textContent = _t("shareButton");

                // Update dynamic button texts
                updateModeButtonText();
                updateSizeButtonText();

                // If message box is visible, re-translate its content (though typically set on demand)
                if (!messageBox.classList.contains('hidden-message-box') && messageBox.dataset.messageKey) {
                     const messageKey = messageBox.dataset.messageKey;
                     const messageType = messageBox.dataset.messageType || 'success'; // or 'error'
                     if (messageKey === "winMessage" || messageKey === "loseMessage") {
                         showMessage(_t(messageKey), messageType);
                     } else if (messageKey === "testWinPrompt"){
                         showMessage(_t(messageKey), messageType);
                     }
                     // Add more specific message key handling if needed
                }
            }
            // --- End of Internationalization (i18n) Setup ---


            // Game Constants - Time Modes
            const CASUAL_TIME_LIMIT = 600; // 10 minutes
            const HELL_TIME_LIMIT = 300;   // 5 minutes

            // Game Constants - Board Sizes (Easy mode is now 10 Rows x 8 Columns)
            const EASY_ROWS = 10; 
            const EASY_COLS = 8;  
            const HARD_ROWS = 16;
            const HARD_COLS = 16;

            // Game Constants - Icons
            const NUM_UNIQUE_ICONS = 32; 
            const IMAGE_PATH_PREFIX = 'img/'; 
            const IMAGE_EXTENSION = '.png';

            // Game State Variables
            let currentMode = 'casual'; 
            let TIME_LIMIT = CASUAL_TIME_LIMIT;
            let currentBoardSize = 'easy'; 
            let ROWS = EASY_ROWS;
            let COLS = EASY_COLS;
            let board = []; 
            let tileElements = []; 
            let firstSelectedTile = null; 
            let secondSelectedTile = null; 
            let timeLeft = TIME_LIMIT;
            let score = 0;
            let timerInterval;
            let remainingTiles = ROWS * COLS;
            let gameActive = false;
            let imagesLoadedCount = 0;
            let totalImagesToLoad = 0;

            let CUTE_ICONS_SOURCES = [];
            for (let i = 1; i <= NUM_UNIQUE_ICONS; i++) {
                CUTE_ICONS_SOURCES.push(`${IMAGE_PATH_PREFIX}animal${i}${IMAGE_EXTENSION}`);
            }

            function showLoadingIndicator(show) {
                if (loadingIndicator) loadingIndicator.style.display = show ? 'block' : 'none';
                if (show) {
                    gameBoardElement.innerHTML = ''; 
                    if (loadingIndicator) gameBoardElement.appendChild(loadingIndicator);
                }
            }

            async function preloadImages(imageSources) {
                showLoadingIndicator(true);
                gameBoardElement.style.pointerEvents = 'none'; 
                const uniqueImageSources = [...new Set(imageSources)];
                totalImagesToLoad = uniqueImageSources.length;
                imagesLoadedCount = 0;

                if (totalImagesToLoad === 0) {
                    console.warn(CUTE_ICONS_SOURCES.length > 0 ? _t("noUniqueImagesPreload") : _t("noImagesOrPathError"));
                    handleAllImagesProcessed(); 
                    return;
                }
                for (const src of uniqueImageSources) {
                    const img = new Image();
                    img.src = src; 
                    img.onload = handleImageLoad;
                    img.onerror = () => handleImageError(src);
                }
            }

            function handleImageLoad() {
                imagesLoadedCount++;
                if (imagesLoadedCount >= totalImagesToLoad) handleAllImagesProcessed();
            }

            function handleImageError(src) {
                console.error(_t("preloadError", src, IMAGE_PATH_PREFIX));
                imagesLoadedCount++; 
                if (imagesLoadedCount >= totalImagesToLoad) handleAllImagesProcessed();
            }

            function handleAllImagesProcessed() {
                showLoadingIndicator(false);
                gameBoardElement.style.pointerEvents = 'auto'; 
                gameActive = true;
                firstSelectedTile = null;
                secondSelectedTile = null;
                timeLeft = TIME_LIMIT; 
                score = 0;
                remainingTiles = ROWS * COLS; 

                updateTimerDisplay();
                updateScoreDisplay();
                hideMessage();
                renderBoard(); 
                startTimer();
            }

            async function initGame() {
                stopTimer();
                gameActive = false; 
                showLoadingIndicator(true);
                if (shareButton) shareButton.style.display = 'none'; 
                createBoardData(); 

                let imagesToPreload = [];
                if (board && board.length > 0) {
                    for (let r = 0; r < ROWS; r++) {
                        if (board[r]) {
                            for (let c = 0; c < COLS; c++) {
                                if (board[r][c] && board[r][c] !== 'placeholder_icon_path') {
                                    imagesToPreload.push(board[r][c]);
                                }
                            }
                        }
                    }
                }
                await preloadImages(imagesToPreload);
            }

            function createBoardData() {
                board = [];
                tileElements = []; 
                const iconPairs = [];
                const numTotalTiles = ROWS * COLS; 
                const numPairsNeeded = numTotalTiles / 2;

                if (numTotalTiles % 2 !== 0) {
                    console.error(_t("oddTilesError"));
                }
                
                if (CUTE_ICONS_SOURCES.length === 0) {
                    console.error(_t("noIconSourcesError"));
                    for (let i = 0; i < numPairsNeeded; i++) {
                        iconPairs.push(`placeholder_icon_path`, `placeholder_icon_path`);
                    }
                } else if (CUTE_ICONS_SOURCES.length < numPairsNeeded / (ROWS*COLS/NUM_UNIQUE_ICONS) && NUM_UNIQUE_ICONS < numPairsNeeded) { 
                     console.warn(_t("notEnoughUniqueIconsWarning", NUM_UNIQUE_ICONS, numPairsNeeded));
                }

                for (let i = 0; i < numPairsNeeded; i++) {
                    iconPairs.push(CUTE_ICONS_SOURCES[i % CUTE_ICONS_SOURCES.length]);
                    iconPairs.push(CUTE_ICONS_SOURCES[i % CUTE_ICONS_SOURCES.length]);
                }
                
                shuffleArray(iconPairs);

                for (let r = 0; r < ROWS; r++) {
                    board[r] = [];
                    tileElements[r] = [];
                    for (let c = 0; c < COLS; c++) {
                        if (iconPairs.length > 0) {
                            board[r][c] = iconPairs.pop();
                        } else {
                            board[r][c] = 'placeholder_icon_path'; 
                            console.error(_t("notEnoughPairsError", r, c));
                        }
                        tileElements[r][c] = null; 
                    }
                }
            }

            function renderBoard() {
                gameBoardElement.innerHTML = ''; 
                
                const tileRenderSize = 32; 
                const gapSize = 2;         
                const boardPadding = 5 * 2;  
                const calculatedWidth = COLS * tileRenderSize + (COLS - 1) * gapSize + boardPadding;
                gameBoardElement.style.width = `min(${calculatedWidth}px, 95vw)`; 

                gameBoardElement.style.gridTemplateColumns = `repeat(${COLS}, 1fr)`;
                gameBoardElement.style.gridTemplateRows = `repeat(${ROWS}, 1fr)`;

                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const tileElement = document.createElement('div');
                        tileElement.classList.add('tile');
                        tileElements[r][c] = tileElement; 
                        const imagePath = board[r] ? board[r][c] : null;

                        if (imagePath && imagePath !== 'placeholder_icon_path') {
                            const img = document.createElement('img');
                            img.src = imagePath;
                            img.alt = `Icon ${r}-${c}`; // Generic alt text, could be translated if needed
                            img.style.pointerEvents = 'none'; 
                            
                            img.onerror = function() { 
                                console.warn(_t("renderImageLoadError", this.src));
                                if (this.parentNode) { 
                                    this.parentNode.textContent = 'ğŸ–¼ï¸'; 
                                }
                                this.remove(); 
                            };
                            tileElement.appendChild(img);
                            tileElement.dataset.row = r; 
                            tileElement.dataset.col = c;
                        } else { 
                            tileElement.innerHTML = '';
                            tileElement.classList.add('hidden'); 
                            if (imagePath === 'placeholder_icon_path') { 
                                tileElement.textContent = 'â”';
                                tileElement.classList.remove('hidden');
                                tileElement.style.cursor = 'default';
                            }
                        }
                        gameBoardElement.appendChild(tileElement);
                        if (!tileElement.classList.contains('hidden') || imagePath === 'placeholder_icon_path') {
                            tileElement.addEventListener('click', handleTileClick);
                        }
                    }
                }
            }

            function handleTileClick(event) {
                if (!gameActive || !event.currentTarget) return; 
                const clickedTileElement = event.currentTarget;
                if (clickedTileElement.classList.contains('hidden') || clickedTileElement.classList.contains('selected')) return;

                const r = parseInt(clickedTileElement.dataset.row);
                const c = parseInt(clickedTileElement.dataset.col);

                if (!board || !board[r] || typeof board[r][c] === 'undefined' || board[r][c] === null || board[r][c] === 'placeholder_icon_path') {
                    console.warn(_t("invalidTileClick", r, c));
                    return;
                }
                clickedTileElement.classList.add('selected');

                if (!firstSelectedTile) { 
                    firstSelectedTile = { r, c, element: clickedTileElement, iconSrc: board[r][c] };
                } else { 
                    if (firstSelectedTile.element === clickedTileElement) { 
                        firstSelectedTile.element.classList.remove('selected');
                        firstSelectedTile = null;
                        return;
                    }
                    secondSelectedTile = { r, c, element: clickedTileElement, iconSrc: board[r][c] };
                    gameBoardElement.style.pointerEvents = 'none'; 
                    setTimeout(() => { 
                        checkMatch();
                        if (gameActive) gameBoardElement.style.pointerEvents = 'auto'; 
                    }, 150);
                }
            }
            
             function getScoreForMatch(currentTimeLeft, mode) {
                if (mode === 'casual') {
                    return 10; 
                } else if (mode === 'hell') {
                    if (currentTimeLeft > 240) return 20; 
                    if (currentTimeLeft > 180) return 18; 
                    if (currentTimeLeft > 120) return 16; 
                    if (currentTimeLeft > 60) return 14;   
                    return 12; 
                }
                return 0; 
            }

            function checkMatch() {
                if (!firstSelectedTile || !secondSelectedTile) return;
                const p1 = firstSelectedTile;
                const p2 = secondSelectedTile;

                if (p1.iconSrc && p2.iconSrc && p1.iconSrc === p2.iconSrc && p1.iconSrc !== 'error_icon') {
                    if (canConnect(p1, p2)) { 
                        p1.element.classList.add('hidden'); p1.element.innerHTML = '';
                        p2.element.classList.add('hidden'); p2.element.innerHTML = '';
                        if (board[p1.r]) board[p1.r][p1.c] = null;
                        if (board[p2.r]) board[p2.r][p2.c] = null;
                        
                        score += getScoreForMatch(timeLeft, currentMode);
                        
                        remainingTiles -= 2;
                        updateScoreDisplay();
                        if (remainingTiles === 0) gameOver(true); 
                    } else { 
                        p1.element.classList.remove('selected');
                        p2.element.classList.remove('selected');
                    }
                } else { 
                    p1.element.classList.remove('selected');
                    if (p2.element) p2.element.classList.remove('selected');
                }
                firstSelectedTile = null;
                secondSelectedTile = null;
            }

            function canConnect(p1, p2) {
                let logicalBoard = [];
                logicalBoard.push(new Array(COLS + 2).fill(null)); 
                for (let i = 0; i < ROWS; i++) {
                    const rowData = board[i] ? [...board[i]] : new Array(COLS).fill(null);
                    logicalBoard.push([null, ...rowData, null]); 
                }
                logicalBoard.push(new Array(COLS + 2).fill(null)); 

                const start = { r: p1.r + 1, c: p1.c + 1 }; 
                const end = { r: p2.r + 1, c: p2.c + 1 };   

                const queue = [{ r: start.r, c: start.c, dir: 0, turns: -1 }]; 
                const visited = Array.from({ length: ROWS + 2 }, () =>
                    Array.from({ length: COLS + 2 }, () => Array(5).fill(false))
                );
                if (visited[start.r] && visited[start.r][start.c]) visited[start.r][start.c][0] = true;

                while (queue.length > 0) {
                    const current = queue.shift();
                    if (current.r === end.r && current.c === end.c && current.turns <= 2) return true; 
                    if (current.turns > 2) continue; 

                    const moves = [[-1, 0, 1], [0, 1, 2], [1, 0, 3], [0, -1, 4]]; 
                    for (const move of moves) {
                        const nextR = current.r + move[0], nextC = current.c + move[1], moveDir = move[2];
                        let nextTurns = current.turns;
                        if (current.dir !== 0 && current.dir !== moveDir) nextTurns++; 
                        if (nextTurns > 2) continue; 

                        if (nextR >= 0 && nextR < ROWS + 2 && nextC >= 0 && nextC < COLS + 2) {
                            if (logicalBoard[nextR] && (logicalBoard[nextR][nextC] === null || (nextR === end.r && nextC === end.c))) {
                                if (visited[nextR] && visited[nextR][nextC] && (!visited[nextR][nextC][moveDir] || (nextR === end.r && nextC === end.c))) {
                                    visited[nextR][nextC][moveDir] = true;
                                    queue.push({ r: nextR, c: nextC, dir: moveDir, turns: nextTurns });
                                }
                            }
                        }
                    }
                }
                return false; 
            }

            function stopTimer() { clearInterval(timerInterval); }

            function startTimer() {
                stopTimer();
                timeLeft = TIME_LIMIT; 
                updateTimerDisplay();
                timerInterval = setInterval(() => {
                    timeLeft--;
                    updateTimerDisplay();
                    if (timeLeft <= 0) gameOver(false); 
                }, 1000);
            }

            function updateTimerDisplay() { timerValueElement.textContent = timeLeft; } // Update only number
            function updateScoreDisplay() { scoreValueElement.textContent = score; } // Update only number

            function gameOver(isWin) {
                gameActive = false;
                stopTimer();
                gameBoardElement.style.pointerEvents = 'none'; 
                const messageKey = isWin ? "winMessage" : "loseMessage";
                showMessage(_t(messageKey), isWin ? "success" : "error", messageKey);


                if (currentMode === 'hell' && isWin && shareButton) {
                    shareButton.style.display = 'inline-block'; 
                } else if (shareButton) {
                    shareButton.style.display = 'none';
                }
            }
            
            function showMessage(text, type, messageKey = null) { // Added messageKey
                messageBox.textContent = text;
                messageBox.className = `message-box ${type}`;
                if (messageKey) { // Store the key for potential re-translation
                    messageBox.dataset.messageKey = messageKey;
                    messageBox.dataset.messageType = type;
                } else {
                    delete messageBox.dataset.messageKey;
                    delete messageBox.dataset.messageType;
                }
            }

            function hideMessage() { 
                messageBox.className = 'message-box hidden-message-box';
                delete messageBox.dataset.messageKey; 
                delete messageBox.dataset.messageType;
            }

            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            function updateModeButtonText() {
                modeToggleButton.textContent = currentMode === 'casual' ? _t("modeButtonHell") : _t("modeButtonCasual");
            }

            function toggleGameMode() {
                currentMode = currentMode === 'casual' ? 'hell' : 'casual';
                TIME_LIMIT = currentMode === 'casual' ? CASUAL_TIME_LIMIT : HELL_TIME_LIMIT;
                updateModeButtonText();
                initGame(); 
            }

            function updateSizeButtonText() {
                sizeToggleButton.textContent = currentBoardSize === 'easy' ? _t("sizeButtonHard", HARD_ROWS, HARD_COLS) : _t("sizeButtonEasy", EASY_ROWS, EASY_COLS);
            }

            function toggleBoardSize() {
                if (currentBoardSize === 'easy') {
                    currentBoardSize = 'hard';
                    ROWS = HARD_ROWS; COLS = HARD_COLS;
                } else {
                    currentBoardSize = 'easy';
                    ROWS = EASY_ROWS; COLS = EASY_COLS;
                }
                updateSizeButtonText();
                initGame(); 
            }

            function copyToClipboard(textToCopy, successMessageText) {
                const textArea = document.createElement('textarea');
                textArea.value = textToCopy;
                textArea.style.position = 'fixed'; 
                textArea.style.left = '-9999px'; 
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    const successful = document.execCommand('copy');
                    if (successful) {
                        showMessage(successMessageText, 'success');
                    } else {
                        showMessage(_t('copyErrorMessage'), 'error');
                        console.error(_t('copyCommandUnsuccessful'));
                    }
                } catch (err) {
                    showMessage(_t('copyErrorMessage'), 'error');
                    console.error(_t('copyUnableError'), err);
                }
                document.body.removeChild(textArea);
            }

            function handleShareScore() {
                const gameUrl = window.location.href; 
                const shareText = _t("shareScoreText", score, gameUrl);

                if (navigator.share) {
                    navigator.share({
                        title: _t("shareTitle"),
                        text: shareText,
                        url: gameUrl,
                    })
                    .then(() => console.log(_t("shareSuccessLog")))
                    .catch((error) => {
                        console.warn(_t("shareCancelledLog"), error);
                        copyToClipboard(shareText, _t("copySuccessMessage"));
                    });
                } else {
                    copyToClipboard(shareText, _t("unsupportedShareMessage"));
                }
            }

            function handleTestWin() {
                 const messageKey = "testWinPrompt";
                if (!gameActive && currentMode !== 'hell') {
                    showMessage(_t(messageKey), 'error', messageKey);
                    return;
                }
                 if (!gameActive && currentMode === 'hell'){
                     score = Math.floor(Math.random() * 100) + 50; 
                     updateScoreDisplay();
                     gameOver(true);
                     return;
                 }
                gameOver(true);
            }

            // Event Listener for language selector
            languageSelector.addEventListener('change', (event) => {
                currentLanguage = event.target.value;
                document.documentElement.lang = currentLanguage.startsWith('zh') ? 'zh-CN' : currentLanguage; // Update html lang
                applyTranslations();
            });


            // Event Listeners
            modeToggleButton.addEventListener('click', toggleGameMode);
            sizeToggleButton.addEventListener('click', toggleBoardSize);
            restartButton.addEventListener('click', initGame);
            if (shareButton) { 
                shareButton.addEventListener('click', handleShareScore);
            }
            if (testWinButton) { 
                testWinButton.addEventListener('click', handleTestWin);
            }

            // Initial Game Setup
            document.documentElement.lang = currentLanguage.startsWith('zh') ? 'zh-CN' : currentLanguage; // Set initial html lang
            applyTranslations(); // Apply translations on initial load
            // updateModeButtonText(); // Called by applyTranslations
            // updateSizeButtonText(); // Called by applyTranslations
            initGame(); 
        });
    </script></body></html>